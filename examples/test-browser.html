<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hoosat SDK Browser Test</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
        background: #1a1a1a;
        color: #e0e0e0;
      }
      .container {
        background: #2a2a2a;
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }
      h1 {
        color: #4caf50;
        margin-top: 0;
      }
      button {
        background: #4caf50;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 16px;
        margin: 10px 10px 10px 0;
        transition: all 0.2s;
      }
      button:hover {
        background: #45a049;
      }
      button:active {
        transform: scale(0.98);
      }
      button:disabled {
        background: #666;
        cursor: not-allowed;
      }
      .output {
        background: #1a1a1a;
        border: 1px solid #404040;
        border-radius: 6px;
        padding: 15px;
        margin-top: 20px;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        white-space: pre-wrap;
        word-break: break-all;
        max-height: 400px;
        overflow-y: auto;
      }
      .success {
        color: #4caf50;
      }
      .error {
        color: #f44336;
      }
      .info {
        color: #2196f3;
      }
      .warning {
        color: #ffc107;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üöÄ Hoosat SDK Browser Test</h1>
      <p>Testing browser-compatible crypto operations</p>

      <h2 style="margin-top: 0; color: #4caf50;">Cryptography Tests</h2>
      <button id="btnGenerateKey">Generate Key Pair</button>
      <button id="btnImportKey">Import Key</button>
      <button id="btnValidateAddress">Validate Address</button>
      <button id="btnTestHashing">Test Hashing</button>

      <h2 style="margin-top: 30px; color: #2196f3;">Message Signing Tests</h2>
      <button id="btnSignMessage">Sign Message</button>
      <button id="btnVerifyMessage">Verify Signature</button>
      <button id="btnTestDAppAuth">Test DApp Auth</button>
      <button id="btnTestRecovery">Test Key Recovery</button>

      <button id="btnClear" style="margin-top: 30px; background: #666;">Clear</button>

      <div id="output" class="output">Loading SDK...</div>
    </div>

    <script type="module">
      const output = document.getElementById('output');

      function log(message, type = 'info') {
        const color = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : type === 'warning' ? '#FFC107' : '#2196F3';
        output.innerHTML += `<span style="color: ${color}">${message}</span>\n`;
        output.scrollTop = output.scrollHeight;
      }

      function clearOutput() {
        output.innerHTML = 'Ready to test...\n';
      }

      // Try to load SDK with error handling
      let HoosatCrypto, HoosatUtils, HoosatSigner, HOOSAT_PARAMS;

      try {
        log('üîÑ Loading Hoosat SDK...', 'info');

        // Import SDK - it will set up Buffer automatically
        const sdk = await import('../dist/hoosat-sdk.es.js');
        HoosatCrypto = sdk.HoosatCrypto;
        HoosatUtils = sdk.HoosatUtils;
        HoosatSigner = sdk.HoosatSigner;
        HOOSAT_PARAMS = sdk.HOOSAT_PARAMS;

        // Buffer should now be available globally (set by index.ts)
        if (typeof Buffer === 'undefined') {
          throw new Error('Buffer is not available. Check index-browser.ts');
        }

        log('‚úÖ SDK loaded successfully!', 'success');
        log('‚úÖ Buffer available globally\n', 'success');
        clearOutput();
        log('SDK ready! Click buttons to test.\n', 'success');
      } catch (error) {
        log(`‚ùå Failed to load SDK: ${error.message}`, 'error');
        log(`\nPlease make sure:`, 'warning');
        log(`1. You ran: npm run build`, 'warning');
        log(`2. File exists: dist/hoosat-sdk.es.js`, 'warning');
        log(`3. You're serving via http:// (not file://)`, 'warning');
        console.error('Full error:', error);

        // Disable buttons if SDK failed to load
        document.querySelectorAll('button').forEach(btn => {
          if (btn.id !== 'btnClear') btn.disabled = true;
        });
      }

      function testGenerateKeyPair() {
        try {
          log('=== Testing Key Pair Generation ===', 'info');

          const wallet = HoosatCrypto.generateKeyPair('mainnet');

          log(`‚úÖ Private Key (32 bytes): ${wallet.privateKey.toString('hex')}`, 'success');
          log(`‚úÖ Public Key (33 bytes): ${wallet.publicKey.toString('hex')}`, 'success');
          log(`‚úÖ Address: ${wallet.address}`, 'success');

          // Validate the generated address
          const isValid = HoosatUtils.isValidAddress(wallet.address);
          log(`‚úÖ Address is valid: ${isValid}`, 'success');

          // Check address type and network
          const network = HoosatUtils.getAddressNetwork(wallet.address);
          const type = HoosatUtils.getAddressType(wallet.address);
          log(`‚úÖ Network: ${network}, Type: ${type}`, 'success');

          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testImportKey() {
        try {
          log('=== Testing Key Import ===', 'info');

          // Generate a key first
          const original = HoosatCrypto.generateKeyPair('mainnet');
          const privateKeyHex = original.privateKey.toString('hex');

          log(`Generated private key: ${privateKeyHex.slice(0, 16)}...`, 'info');

          // Import it back
          const imported = HoosatCrypto.importKeyPair(privateKeyHex, 'mainnet');

          log(`‚úÖ Original Address: ${original.address}`, 'success');
          log(`‚úÖ Imported Address: ${imported.address}`, 'success');
          log(`‚úÖ Addresses match: ${original.address === imported.address}`, 'success');

          // Test invalid key
          try {
            HoosatCrypto.importKeyPair('0000000000000000000000000000000000000000000000000000000000000000', 'mainnet');
            log('‚ö†Ô∏è  Invalid key was accepted (unexpected)', 'warning');
          } catch (e) {
            log(`‚úÖ Invalid key correctly rejected`, 'success');
          }

          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testAddressValidation() {
        try {
          log('=== Testing Address Validation ===', 'info');

          // Generate valid address
          const wallet = HoosatCrypto.generateKeyPair('mainnet');

          log(`Testing address: ${wallet.address}`, 'info');
          log(`‚úÖ Is valid: ${HoosatUtils.isValidAddress(wallet.address)}`, 'success');

          // Test invalid addresses
          const testCases = [
            { addr: 'invalid:address123', expected: false, desc: 'Invalid format' },
            { addr: 'hoosat:invalid', expected: false, desc: 'Invalid payload' },
            { addr: 'bitcoin:qz7ulu', expected: false, desc: 'Wrong prefix' },
          ];

          log('\nTesting invalid addresses:', 'info');
          testCases.forEach(test => {
            const isValid = HoosatUtils.isValidAddress(test.addr);
            const result = isValid === test.expected ? '‚úÖ' : '‚ùå';
            log(`${result} ${test.desc}: ${isValid}`, isValid === test.expected ? 'success' : 'error');
          });

          // Test address info
          const network = HoosatUtils.getAddressNetwork(wallet.address);
          const type = HoosatUtils.getAddressType(wallet.address);
          log(`\n‚úÖ Network: ${network}`, 'success');
          log(`‚úÖ Type: ${type}`, 'success');

          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testHashing() {
        try {
          log('=== Testing Hashing Functions ===', 'info');

          const data = Buffer.from('Hello Hoosat!', 'utf8');
          log(`Input: "Hello Hoosat!" (${data.length} bytes)\n`, 'info');

          // Blake3 hash
          const blake3Hash = HoosatCrypto.blake3Hash(data);
          log(`Blake3 (32 bytes):`, 'info');
          log(`  ${blake3Hash.toString('hex')}`, 'success');

          // Double Blake3 hash
          const doubleHash = HoosatCrypto.doubleBlake3Hash(data);
          log(`\nDouble Blake3 (32 bytes):`, 'info');
          log(`  ${doubleHash.toString('hex')}`, 'success');

          // Keyed hash
          const keyedHash = HoosatCrypto.blake3KeyedHash('TransactionSigningHash', data);
          log(`\nKeyed Blake3 (key: "TransactionSigningHash"):`, 'info');
          log(`  ${keyedHash.toString('hex')}`, 'success');

          // SHA256 hash
          const sha256Hash = HoosatCrypto.sha256Hash(data);
          log(`\nSHA256 (32 bytes):`, 'info');
          log(`  ${sha256Hash.toString('hex')}`, 'success');

          // Verify all hashes are 32 bytes
          const allCorrectLength = [blake3Hash, doubleHash, keyedHash, sha256Hash].every(hash => hash.length === 32);

          log(`\n‚úÖ All hashes are 32 bytes: ${allCorrectLength}`, 'success');
          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testSignMessage() {
        try {
          log('=== Testing Message Signing ===', 'info');

          // Generate a wallet
          const wallet = HoosatCrypto.generateKeyPair('mainnet');
          log(`üìç Address: ${wallet.address}`, 'info');
          log(`üîë Private key: ${wallet.privateKey.toString('hex').slice(0, 16)}...\n`, 'info');

          // Sign a message
          const message = 'Hello, Hoosat! This is a test message.\nTimestamp: ' + Date.now();
          log(`üìù Message to sign:\n"${message}"\n`, 'info');

          const privateKey = wallet.privateKey.toString('hex');
          const signature = HoosatSigner.signMessage(privateKey, message);

          log(`‚úÖ Signature (128 hex chars):`, 'success');
          log(`  ${signature.slice(0, 64)}`, 'success');
          log(`  ${signature.slice(64, 128)}\n`, 'success');

          // Verify the signature
          const publicKey = wallet.publicKey.toString('hex');
          const isValid = HoosatSigner.verifyMessage(signature, message, publicKey);

          log(`‚úÖ Signature is valid: ${isValid}`, 'success');
          log(`‚úÖ Signature length: ${signature.length} chars (64 bytes)\n`, 'success');

          // Test determinism
          const signature2 = HoosatSigner.signMessage(privateKey, message);
          const isDeterministic = signature === signature2;
          log(`‚úÖ Signatures are deterministic: ${isDeterministic}`, 'success');

          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testVerifyMessage() {
        try {
          log('=== Testing Signature Verification ===', 'info');

          // Create wallet and sign a message
          const wallet = HoosatCrypto.generateKeyPair('mainnet');
          const message = 'Verify this message';
          const privateKey = wallet.privateKey.toString('hex');
          const publicKey = wallet.publicKey.toString('hex');

          log(`üìù Original message: "${message}"`, 'info');
          log(`üìç Address: ${wallet.address}\n`, 'info');

          // Sign the message
          const signature = HoosatSigner.signMessage(privateKey, message);
          log(`‚úÖ Signature created`, 'success');

          // Test 1: Valid signature
          const validResult = HoosatSigner.verifyMessage(signature, message, publicKey);
          log(`\n‚úÖ Valid signature verification: ${validResult}`, validResult ? 'success' : 'error');

          // Test 2: Wrong message
          const wrongMessage = 'Different message';
          const wrongMessageResult = HoosatSigner.verifyMessage(signature, wrongMessage, publicKey);
          log(`‚úÖ Wrong message rejection: ${!wrongMessageResult}`, !wrongMessageResult ? 'success' : 'error');

          // Test 3: Wrong public key
          const wallet2 = HoosatCrypto.generateKeyPair('mainnet');
          const wrongKey = wallet2.publicKey.toString('hex');
          const wrongKeyResult = HoosatSigner.verifyMessage(signature, message, wrongKey);
          log(`‚úÖ Wrong public key rejection: ${!wrongKeyResult}`, !wrongKeyResult ? 'success' : 'error');

          // Test 4: Invalid signature format
          const invalidSig = 'invalid_signature';
          const invalidSigResult = HoosatSigner.verifyMessage(invalidSig, message, publicKey);
          log(`‚úÖ Invalid signature rejection: ${!invalidSigResult}`, !invalidSigResult ? 'success' : 'error');

          log('\n‚úÖ All verification tests passed!', 'success');
          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testDAppAuth() {
        try {
          log('=== Testing DApp Authentication Flow ===', 'info');

          // Simulate DApp authentication scenario
          log('üåê Scenario: User signing into a DApp\n', 'info');

          // Step 1: Generate user wallet
          const wallet = HoosatCrypto.generateKeyPair('mainnet');
          log('üë§ User wallet generated:', 'info');
          log(`   Address: ${wallet.address}`, 'info');

          // Step 2: DApp creates challenge
          const nonce = Date.now();
          const dappName = 'MyAwesomeDApp';
          const challenge = `Sign in to ${dappName}\n\nNonce: ${nonce}\nAddress: ${wallet.address}`;

          log(`\nüéØ DApp creates challenge:`, 'info');
          log(`"${challenge}"\n`, 'warning');

          // Step 3: User signs the challenge (in wallet)
          const privateKey = wallet.privateKey.toString('hex');
          const signedMessage = HoosatSigner.createSignedMessage(
            privateKey,
            challenge,
            wallet.address
          );

          log('‚úçÔ∏è  User signs challenge in wallet:', 'success');
          log(`   Signature: ${signedMessage.signature.slice(0, 32)}...`, 'success');
          log(`   Timestamp: ${new Date(signedMessage.timestamp).toLocaleString()}`, 'success');

          // Step 4: DApp receives signed message and verifies
          log(`\nüîç DApp verifies signature:`, 'info');

          const publicKey = wallet.publicKey.toString('hex');
          const verificationResult = HoosatSigner.verifySignedMessage(signedMessage, publicKey);

          if (verificationResult.valid) {
            log(`‚úÖ Authentication successful!`, 'success');
            log(`   User authenticated as: ${signedMessage.address}`, 'success');
            log(`   Public key verified: ${verificationResult.publicKey.slice(0, 16)}...`, 'success');
          } else {
            log(`‚ùå Authentication failed: ${verificationResult.error}`, 'error');
          }

          // Step 5: Simulate attack - tampered message
          log(`\nüîê Security test: Tampered message`, 'warning');
          const tamperedMessage = { ...signedMessage, message: 'Hacked message' };
          const tamperedResult = HoosatSigner.verifySignedMessage(tamperedMessage, publicKey);

          if (!tamperedResult.valid) {
            log(`‚úÖ Tampered message correctly rejected!`, 'success');
            log(`   Error: ${tamperedResult.error}`, 'info');
          } else {
            log(`‚ùå Security breach: tampered message accepted!`, 'error');
          }

          log('\n‚úÖ DApp authentication flow completed successfully!', 'success');
          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      function testKeyRecovery() {
        try {
          log('=== Testing Public Key Recovery ===', 'info');

          // Generate wallet and sign message
          const wallet = HoosatCrypto.generateKeyPair('mainnet');
          const message = 'Message for key recovery test';
          const privateKey = wallet.privateKey.toString('hex');
          const originalPublicKey = wallet.publicKey.toString('hex');

          log(`üìù Message: "${message}"`, 'info');
          log(`üîë Original public key: ${originalPublicKey.slice(0, 32)}...\n`, 'info');

          // Sign the message
          const signature = HoosatSigner.signMessage(privateKey, message);
          log(`‚úÖ Message signed`, 'success');

          // Try to recover public key (try recovery IDs 0-3)
          log(`\nüîç Attempting to recover public key...`, 'info');

          let recovered = false;
          for (let recoveryId = 0; recoveryId < 4; recoveryId++) {
            try {
              const recoveredKey = HoosatSigner.recoverPublicKey(signature, message, recoveryId);

              // Verify with recovered key
              const isValid = HoosatSigner.verifyMessage(signature, message, recoveredKey);

              if (isValid) {
                log(`\n‚úÖ Public key recovered with recovery ID ${recoveryId}!`, 'success');
                log(`   Recovered: ${recoveredKey.slice(0, 32)}...`, 'success');
                log(`   Matches original: ${recoveredKey === originalPublicKey}`, 'success');
                recovered = true;
                break;
              }
            } catch (e) {
              // This recovery ID didn't work, try next
            }
          }

          if (!recovered) {
            log(`‚ö†Ô∏è  Could not recover public key with any recovery ID`, 'warning');
          }

          log('\n', 'info');
        } catch (error) {
          log(`‚ùå Error: ${error.message}`, 'error');
          console.error('Full error:', error);
        }
      }

      // Attach event listeners to buttons
      document.getElementById('btnGenerateKey').addEventListener('click', testGenerateKeyPair);
      document.getElementById('btnImportKey').addEventListener('click', testImportKey);
      document.getElementById('btnValidateAddress').addEventListener('click', testAddressValidation);
      document.getElementById('btnTestHashing').addEventListener('click', testHashing);
      document.getElementById('btnSignMessage').addEventListener('click', testSignMessage);
      document.getElementById('btnVerifyMessage').addEventListener('click', testVerifyMessage);
      document.getElementById('btnTestDAppAuth').addEventListener('click', testDAppAuth);
      document.getElementById('btnTestRecovery').addEventListener('click', testKeyRecovery);
      document.getElementById('btnClear').addEventListener('click', clearOutput);

      // Add click feedback
      document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', function () {
          console.log(`Button clicked: ${this.id}`);
        });
      });
    </script>
  </body>
</html>
